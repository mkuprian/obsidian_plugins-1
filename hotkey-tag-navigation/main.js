/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AdvanceTagPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openingTagDelimiter: "|<",
  closingTagDelimiter: ">|",
  showDebugInfo: false,
  wrapAroundEnabled: true,
  selectInnerByDefault: false
};
var AdvanceTagSettingTab = class extends import_obsidian.PluginSettingTab {
  plugin;
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Advance Tag Navigator Settings" });
    new import_obsidian.Setting(containerEl).setName("Opening tag delimiter").setDesc("The delimiter used to wrap tagged text (default: |<)").addText((text) => text.setPlaceholder("|<").setValue(this.plugin.settings.openingTagDelimiter).onChange(async (value) => {
      if (value.length > 0) {
        this.plugin.settings.openingTagDelimiter = value;
        await this.plugin.saveSettings();
        this.plugin.parser.setOpeningDelimiter(value);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Closing tag delimiter").setDesc("The delimiter used to wrap tagged text (default: |>)").addText((text) => text.setPlaceholder("|>").setValue(this.plugin.settings.closingTagDelimiter).onChange(async (value) => {
      if (value.length > 0) {
        this.plugin.settings.closingTagDelimiter = value;
        await this.plugin.saveSettings();
        this.plugin.parser.setClosingDelimiter(value);
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Select inner content by default").setDesc("When enabled, selections will exclude the delimiters").addToggle((toggle) => toggle.setValue(this.plugin.settings.selectInnerByDefault).onChange(async (value) => {
      this.plugin.settings.selectInnerByDefault = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Wrap around navigation").setDesc("When reaching the last tag, wrap to the first tag").addToggle((toggle) => toggle.setValue(this.plugin.settings.wrapAroundEnabled).setValue(this.plugin.settings.wrapAroundEnabled).onChange(async (value) => {
      this.plugin.settings.wrapAroundEnabled = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Show debug information").setDesc("Display tag structure information in console (for development)").addToggle((toggle) => toggle.setValue(this.plugin.settings.showDebugInfo).onChange(async (value) => {
      this.plugin.settings.showDebugInfo = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Advance to next tag").setDesc("Set hotkey for advancing to the next tag (default: Mod+Shift+Right Arrow)").addText((text) => text.setPlaceholder("Mod+Shift+Right Arrow").setValue(this.plugin.advanceHotkey.modifiers.join("+") + "+" + this.plugin.advanceHotkey.key).onChange(async (value) => {
      const [modifiers, key] = value.split("+");
      this.plugin.advanceHotkey = {
        modifiers: modifiers.split("+"),
        key
      };
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Usage Examples" });
    const exampleEl = containerEl.createDiv();
    exampleEl.createEl("p", {
      text: "With delimiters |< >|, you can write:"
    });
    exampleEl.createEl("pre", {
      text: "I like to eat |<spaghetti>|.\nFor dinner: |<spaghetti>| or |<pastrami>|."
    });
    exampleEl.createEl("p", {
      text: "Use the advance command to navigate through tags."
    });
  }
};

// src/parser.ts
var Parser = class {
  logger;
  settings;
  openingDelimiter;
  closingDelimiter;
  tagStruct = null;
  constructor(settings, openingDelimiter, closingDelimiter) {
    this.settings = settings;
    this.openingDelimiter = openingDelimiter;
    this.closingDelimiter = closingDelimiter;
  }
  reset() {
    this.tagStruct = null;
  }
  setLogger(logger) {
    this.logger = logger;
  }
  setOpeningDelimiter(delimiter) {
    this.openingDelimiter = delimiter;
  }
  setClosingDelimiter(delimiter) {
    this.closingDelimiter = delimiter;
  }
  getTagPosition() {
    if (this.tagStruct) {
      return {
        parentStart: this.tagStruct.parentStart,
        parentEnd: this.tagStruct.parentEnd
      };
    }
    return null;
  }
  checkInTag(editor) {
    const cursorStartPos = editor.getCursor("from");
    const cursorEndPos = editor.getCursor("to");
    const cursorStartIndex = editor.posToOffset(cursorStartPos);
    const cursorEndIndex = editor.posToOffset(cursorEndPos);
    if (cursorEndIndex - cursorStartIndex > 0) {
      const selectedText = editor.getSelection();
      if (selectedText.startsWith(this.openingDelimiter) && selectedText.endsWith(this.closingDelimiter)) {
        return true;
      }
      return false;
    }
    return false;
  }
  getTagContent() {
    return this.tagStruct ? this.tagStruct.content : null;
  }
  getInnerTagPosition() {
    if (this.tagStruct) {
      return {
        innerStart: this.tagStruct.innerStart,
        innerEnd: this.tagStruct.innerEnd
      };
    }
    return null;
  }
  getInnerTagContent() {
    if (this.tagStruct) {
      return this.tagStruct.content;
    }
    return null;
  }
  highlightTag(editor) {
    if (this.tagStruct) {
      const startPos = editor.offsetToPos(this.tagStruct.parentStart);
      const endPos = editor.offsetToPos(this.tagStruct.parentEnd);
      editor.setSelection(startPos, endPos);
      return true;
    }
    return false;
  }
  highlightInnerTag(editor) {
    if (this.tagStruct) {
      const startPos = editor.offsetToPos(this.tagStruct.innerStart);
      const endPos = editor.offsetToPos(this.tagStruct.innerEnd);
      editor.setSelection(startPos, endPos);
      return true;
    }
    return false;
  }
  acceptDefaultText(editor) {
    if (this.tagStruct) {
      const innerContent = this.tagStruct.content;
      editor.replaceRange(innerContent, editor.offsetToPos(this.tagStruct.parentStart), editor.offsetToPos(this.tagStruct.parentEnd));
      const startPos = editor.offsetToPos(this.tagStruct.innerStart - this.openingDelimiter.length);
      const endPos = editor.offsetToPos(this.tagStruct.innerEnd - this.closingDelimiter.length);
      editor.setSelection(startPos, endPos);
      return true;
    }
    return false;
  }
  parse(editor, forward = true, wrapCheck = false) {
    this.logger.debug(`Starting parse in ${forward ? "forward" : "backward"} direction, wrapCheck: ${wrapCheck}`);
    if (wrapCheck && this.tagStruct === null) {
      this.logger.debug("Wrap-around completed, no tags found");
      return false;
    }
    let initTag = false;
    const direction = forward ? 1 : -1;
    const cursorStartPos = editor.getCursor("from");
    const cursorEndPos = editor.getCursor("to");
    const content = editor.getValue();
    console.log(`from: ${editor.posToOffset(cursorStartPos)}`);
    console.log(`to: ${editor.posToOffset(cursorEndPos)}`);
    let cursorIndex;
    if (!forward) {
      cursorIndex = editor.posToOffset(cursorStartPos) - 1;
    } else {
      cursorIndex = editor.posToOffset(cursorEndPos);
    }
    console.log(`Cursor position: ${cursorStartPos.line}, ${cursorStartPos.ch} (index ${cursorIndex})`);
    const wrapAround = this.settings.wrapAroundEnabled;
    console.log(`We are starting to walk the document ${forward ? "forwards" : "backwards"} with a start index of ${cursorIndex} and wrapAround set to ${wrapAround}`);
    for (let i = cursorIndex; forward ? i < content.length : i >= 0; i += direction) {
      if (content.startsWith(this.openingDelimiter, i)) {
        this.logger.debug(`Found opening delimiter at index ${i} with initTag=${initTag}`);
        console.log(`Found opening delimiter at index ${i} with initTag=${initTag} and direction of ${forward ? "forward" : "backward"}`);
        if (!initTag && !forward) {
          console.log("Ignoring opening tag while searching backward");
          continue;
        } else if (!initTag && forward) {
          console.log(`Found first opening tag at index ${i} setting initTag to true`);
          initTag = true;
          this.tagStruct = {
            parentStart: i,
            parentEnd: -1,
            innerStart: i + this.openingDelimiter.length,
            innerEnd: -1,
            content: "",
            openingTagPos: [i],
            closingTagPos: []
          };
        } else if (initTag) {
          console.log(`Found nested opening tag at index ${i}`);
          this.tagStruct?.openingTagPos.push(i);
          if (!forward && this.tagStruct) {
            console.log(`Found nested opening tag at index ${i} updating innerStart and parentStart`);
            this.tagStruct.innerStart = i + this.openingDelimiter.length;
            this.tagStruct.parentStart = i;
          }
          if (this.tagStruct && this.tagStruct.closingTagPos.length > 0) {
            this.tagStruct.openingTagPos.pop();
            this.tagStruct.closingTagPos.pop();
            console.log("Checking for complete tag after nested opening tag, current openingTagPos length:", this.tagStruct.openingTagPos.length);
            console.log("Current closingTagPos length:", this.tagStruct.closingTagPos.length);
            if (this.tagStruct.openingTagPos.length === 0 && this.tagStruct.closingTagPos.length === 0) {
              console.log("Complete tag found:", this.tagStruct);
              this.tagStruct.content = content.substring(this.tagStruct.innerStart, this.tagStruct.innerEnd);
              return true;
            }
          }
        }
      } else if (content.startsWith(this.closingDelimiter, i)) {
        console.log(`Found closing delimiter at index ${i} with initTag=${initTag} and direction of ${forward ? "forward" : "backward"}`);
        if (!initTag && forward) {
          console.log("Ignoring closing tag while searching forward");
          continue;
        } else if (!initTag && !forward) {
          console.log(`Found init closing tag at index ${i} setting initTag to true`);
          initTag = true;
          this.tagStruct = {
            parentStart: -1,
            parentEnd: i + this.closingDelimiter.length,
            innerStart: -1,
            innerEnd: i,
            content: "",
            openingTagPos: [],
            closingTagPos: [i]
          };
        } else if (initTag) {
          console.log(`Found nested closing tag at index ${i}`);
          this.tagStruct?.closingTagPos.push(i);
          if (forward && this.tagStruct) {
            console.log(`Found nested closing tag at index ${i} updating innerEnd and parentEnd`);
            this.tagStruct.innerEnd = i;
            this.tagStruct.parentEnd = i + this.closingDelimiter.length;
          }
          console.log(`Now check if we can pop off any opening tags if we have found a matching pair`);
          console.log(`Current openingTagPos length: ${this.tagStruct ? this.tagStruct.openingTagPos.length : `tag not found`}`);
          if (this.tagStruct && this.tagStruct.openingTagPos.length > 0) {
            this.tagStruct.closingTagPos.pop();
            this.tagStruct.openingTagPos.pop();
            console.log("Checking for complete tag after nested opening tag, current openingTagPos length:", this.tagStruct.openingTagPos.length);
            console.log("Current closingTagPos length:", this.tagStruct.closingTagPos.length);
            if (this.tagStruct.closingTagPos.length === 0 && this.tagStruct.openingTagPos.length === 0) {
              console.log("Complete tag found:", this.tagStruct);
              this.tagStruct.content = content.substring(this.tagStruct.innerStart, this.tagStruct.innerEnd);
              return true;
            }
          }
        }
      }
    }
    if (this.tagStruct === null && wrapAround && !wrapCheck) {
      console.log("No tag found, attempting wrap-around search");
      if (forward) {
        editor.setCursor(editor.offsetToPos(0));
        return this.parse(editor, true, true);
      } else {
        editor.setCursor(editor.offsetToPos(editor.getValue().length));
        return this.parse(editor, false, true);
      }
    } else {
      this.tagStruct = null;
      return false;
    }
    return false;
  }
};

// src/logger.ts
var import_obsidian2 = require("obsidian");
var Logger = class {
  currentLogLevel;
  app;
  logFolderPath = ".obsidian/plugins/hotkey-tag-navigation/logs";
  constructor(app, logLevel = "INFO" /* INFO */) {
    this.app = app;
    this.currentLogLevel = logLevel;
    this.initializeLogFolder();
  }
  async initializeLogFolder() {
    try {
      const logFolder = this.app.vault.getAbstractFileByPath(this.logFolderPath);
      if (!logFolder) {
        await this.app.vault.createFolder(this.logFolderPath);
      }
    } catch (error) {
      console.warn("Could not create log folder:", error);
    }
  }
  async appendToLogFile(message) {
    try {
      const logFileName = `log_${(/* @__PURE__ */ new Date()).toISOString().slice(0, 10)}.txt`;
      const logFilePath = `${this.logFolderPath}/${logFileName}`;
      try {
        const logFile = this.app.vault.getAbstractFileByPath(logFilePath);
        if (logFile instanceof import_obsidian2.TFile) {
          const currentContent = await this.app.vault.read(logFile);
          await this.app.vault.modify(logFile, currentContent + message + "\n");
          return;
        }
      } catch (readError) {
      }
      try {
        await this.app.vault.create(logFilePath, message + "\n");
      } catch (createError) {
        try {
          const existingFile = this.app.vault.getAbstractFileByPath(logFilePath);
          if (existingFile instanceof import_obsidian2.TFile) {
            const currentContent = await this.app.vault.read(existingFile);
            await this.app.vault.modify(existingFile, currentContent + message + "\n");
          } else {
            console.warn("Could not create or find log file, logging to console only:", message);
          }
        } catch (finalError) {
          console.warn("All log file operations failed, logging to console only:", message);
        }
      }
    } catch (error) {
      console.warn("Could not write to log file:", error);
    }
  }
  info(message) {
    if (this.shouldLog("INFO" /* INFO */)) {
      console.info(`[INFO]: ${message}`);
      this.appendToLogFile(`[INFO]: ${message}`);
    }
  }
  warn(message) {
    if (this.shouldLog("WARN" /* WARN */)) {
      console.warn(`[WARN]: ${message}`);
      this.appendToLogFile(`[WARN]: ${message}`);
    }
  }
  error(message) {
    if (this.shouldLog("ERROR" /* ERROR */)) {
      console.error(`[ERROR]: ${message}`);
      this.appendToLogFile(`[ERROR]: ${message}`);
    }
  }
  debug(message) {
    if (this.shouldLog("DEBUG" /* DEBUG */)) {
      console.debug(`[DEBUG]: ${message}`);
      this.appendToLogFile(`[DEBUG]: ${message}`);
    }
  }
  shouldLog(level) {
    const levels = ["DEBUG" /* DEBUG */, "INFO" /* INFO */, "WARN" /* WARN */, "ERROR" /* ERROR */];
    return levels.indexOf(level) >= levels.indexOf(this.currentLogLevel);
  }
  setLogLevel(level) {
    this.currentLogLevel = level;
  }
};

// src/main.ts
var AdvanceTagPlugin = class extends import_obsidian3.Plugin {
  settings;
  editor;
  parser;
  logger;
  logLevel = "DEBUG" /* DEBUG */;
  advanceHotkey = {
    modifiers: ["Mod", "Shift"],
    key: "ArrowRight"
  };
  previousHotkey = {
    modifiers: ["Mod", "Shift"],
    key: "ArrowLeft"
  };
  selectInnerHotkey = {
    modifiers: ["Mod", "Shift"],
    key: "i"
  };
  removeTagAtCursorHotkey = {
    modifiers: ["Mod", "Shift"],
    key: "Backspace"
  };
  removeAllTagsInSelectionHotkey = {
    modifiers: ["Mod", "Shift", "Alt"],
    key: "Backspace"
  };
  async onload() {
    this.logger = new Logger(this.app, "DEBUG" /* DEBUG */);
    this.logger.info("Advance Tag Navigator plugin is loading");
    await this.loadSettings();
    this.parser = new Parser(this.settings, this.settings.openingTagDelimiter, this.settings.closingTagDelimiter);
    this.parser.setLogger(this.logger);
    this.logger.debug("Registering commands");
    this.addCommand({
      id: "advance-to-next-tag",
      name: "Advance to next tag",
      editorCallback: (editor, view) => {
        const success = this.parser.parse(editor, true);
        if (!success) {
          new import_obsidian3.Notice("No tags found in document");
        } else {
          this.parser.highlightTag(editor);
        }
      },
      hotkeys: [
        this.advanceHotkey
      ]
    });
    this.addCommand({
      id: "advance-to-previous-tag",
      name: "Advance to previous tag",
      editorCallback: (editor, view) => {
        const success = this.parser.parse(editor, false);
        if (!success) {
          new import_obsidian3.Notice("No tags found in document");
        } else {
          this.parser.highlightTag(editor);
        }
      },
      hotkeys: [
        this.previousHotkey
      ]
    });
    this.addCommand({
      id: "select-inner-content",
      name: "Select inner content (without delimiters). If a either no text is selected or the selected text is not a tag, will advance to next tag",
      editorCallback: (editor, view) => {
        console.log(`Selecting inner text`);
        console.log(`Current tag content is ${this.parser.getTagContent}`);
        console.log(`Check in tag = ${this.parser.checkInTag(editor)}`);
        let parseCheck = false;
        let success = false;
        if (!this.parser.checkInTag(editor)) {
          success = this.parser.parse(editor, true);
        }
        ;
        parseCheck = true;
        if (parseCheck || success) {
          this.parser.highlightInnerTag(editor);
        } else {
          new import_obsidian3.Notice("Cursor is not inside a tag");
        }
      },
      hotkeys: [
        this.selectInnerHotkey
      ]
    });
    this.addCommand({
      id: "keep-tag-default-content",
      name: "Remove tag at cursor keeping the default content",
      editorCallback: (editor, view) => {
        let parseSuccess = false;
        console.log(`Selecting inner text`);
        console.log(`Current tag content is ${this.parser.getTagContent}`);
        console.log(`Check in tag = ${this.parser.checkInTag(editor)}`);
        if (!this.parser.checkInTag(editor)) {
          parseSuccess = this.parser.parse(editor, true);
        } else {
          parseSuccess = true;
        }
        if (parseSuccess) {
          const success = this.parser.acceptDefaultText(editor);
          if (success) {
            new import_obsidian3.Notice("Tag removed");
          } else {
            new import_obsidian3.Notice("Failed to remove tag");
          }
        } else {
          new import_obsidian3.Notice("Cursor is not inside a tag");
        }
      },
      hotkeys: [
        this.removeTagAtCursorHotkey
      ]
    });
    this.addSettingTab(new AdvanceTagSettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.parser.reset();
      })
    );
  }
  onunload() {
    console.log("Unloading Advance Tag Navigator plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
