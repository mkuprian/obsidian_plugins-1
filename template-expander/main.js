/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SnippetExpanderPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/snippetParser.ts
var SnippetParser = class {
  constructor(app, vault) {
    this.app = app;
    this.vault = vault;
  }
  /**
   * Parse inline snippets from markdown content
   * Format: --> key || template <--
   */
  parseInlineSnippets(content) {
    const snippets = /* @__PURE__ */ new Map();
    const inlineRegex = /-->\s*([^\|]+?)\s*\|\|\s*([\s\S]*?)\s*<--/g;
    let match;
    while ((match = inlineRegex.exec(content)) !== null) {
      const key = match[1].trim();
      const template = match[2].trim();
      if (key && template) {
        snippets.set(key, {
          key,
          template: this.unescapeTemplate(template),
          description: "Inline snippet"
        });
      }
    }
    return snippets;
  }
  /**
   * Parse snippets from frontmatter YAML (manual parsing - no dependencies)
   */
  parseFrontmatterSnippets(content) {
    const snippets = /* @__PURE__ */ new Map();
    const frontmatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontmatterMatch) return snippets;
    const yamlContent = frontmatterMatch[1];
    const snippetSectionMatch = yamlContent.match(/snippets:\s*\n((?:  .+\n?)*)/);
    if (!snippetSectionMatch) return snippets;
    const snippetSection = snippetSectionMatch[1];
    const lineRegex = /^\s{2}([^:]+):\s*(?:"([^"]*)"|'([^']*)'|(.+))$/gm;
    let lineMatch;
    while ((lineMatch = lineRegex.exec(snippetSection)) !== null) {
      const key = lineMatch[1].trim();
      const template = lineMatch[2] || lineMatch[3] || lineMatch[4];
      if (key && template) {
        snippets.set(key, {
          key,
          template: this.unescapeTemplate(template.trim())
        });
      }
    }
    return snippets;
  }
  /**
   * Load snippets from JSON file using Vault adapter
   */
  async loadJSONSnippets(filePath) {
    const snippets = /* @__PURE__ */ new Map();
    try {
      const pluginDir = `${this.vault.configDir}/plugins/snippet-expander`;
      const fullPath = `${pluginDir}/${filePath}`;
      const adapter = this.app.vault.adapter;
      const exists = await adapter.exists(fullPath);
      if (!exists) {
        console.log(`Snippet file not found: ${fullPath}`);
        return snippets;
      }
      const jsonContent = await adapter.read(fullPath);
      const data = JSON.parse(jsonContent);
      if (Array.isArray(data)) {
        data.forEach((item) => {
          if (item.key && item.template) {
            snippets.set(item.key, {
              key: item.key,
              template: item.template,
              description: item.description
            });
          }
        });
      } else if (typeof data === "object") {
        Object.entries(data).forEach(([key, value]) => {
          if (typeof value === "string") {
            snippets.set(key, { key, template: value });
          } else if (typeof value === "object" && value !== null) {
            const obj = value;
            snippets.set(key, {
              key,
              template: obj.template || String(value),
              description: obj.description
            });
          }
        });
      }
      console.log(`Loaded ${snippets.size} snippets from ${filePath}`);
    } catch (error) {
      console.error("Failed to load JSON snippets:", error);
    }
    return snippets;
  }
  /**
   * Unescape special sequences in templates
   */
  unescapeTemplate(template) {
    return template.replace(/\\n/g, "\n").replace(/\\t/g, "	").replace(/\\r/g, "\r");
  }
  /**
   * Process template variables at expansion time
   */
  processTemplate(template, context) {
    let processed = template;
    const now = /* @__PURE__ */ new Date();
    processed = processed.replace(/\$date\$/g, now.toLocaleDateString()).replace(/\$time\$/g, now.toLocaleTimeString()).replace(/\$datetime\$/g, now.toLocaleString()).replace(/\$year\$/g, String(now.getFullYear())).replace(/\$month\$/g, String(now.getMonth() + 1).padStart(2, "0")).replace(/\$day\$/g, String(now.getDate()).padStart(2, "0"));
    if (context?.fileName) {
      processed = processed.replace(/\$filename\$/g, context.fileName);
    }
    if (context?.filePath) {
      processed = processed.replace(/\$filepath\$/g, context.filePath);
    }
    return processed;
  }
  /**
   * Extract cursor position markers from template
   * Returns [processed_template, cursor_offset_from_start]
   */
  extractCursorMarker(template) {
    const markers = ["$CURSOR$", "$END$", "$end$", "$cursor$"];
    for (const marker of markers) {
      const index = template.indexOf(marker);
      if (index !== -1) {
        const processed = template.replace(marker, "");
        return [processed, index];
      }
    }
    return [template, null];
  }
};

// src/snippetManager.ts
var SnippetManager = class {
  constructor(app, settings) {
    this.app = app;
    this.snippets = /* @__PURE__ */ new Map();
    this.parser = new SnippetParser(app, app.vault);
    this.settings = settings;
  }
  /**
   * Reload all snippets from all sources
   */
  async reloadSnippets(currentFile) {
    const newSnippets = /* @__PURE__ */ new Map();
    if (this.settings.jsonFilePath) {
      const jsonSnippets = await this.parser.loadJSONSnippets(
        this.settings.jsonFilePath
      );
      jsonSnippets.forEach((snippet, key) => newSnippets.set(key, snippet));
    }
    if (this.settings.parseInlineSnippets && currentFile) {
      const content = await this.app.vault.read(currentFile);
      const frontmatterSnippets = this.parser.parseFrontmatterSnippets(content);
      frontmatterSnippets.forEach((snippet, key) => newSnippets.set(key, snippet));
      const inlineSnippets = this.parser.parseInlineSnippets(content);
      inlineSnippets.forEach((snippet, key) => newSnippets.set(key, snippet));
    }
    this.snippets = newSnippets;
    console.log(`Snippet registry updated: ${this.snippets.size} snippets loaded`);
  }
  /**
   * Find snippet by key (respecting case sensitivity setting)
   */
  findSnippet(key) {
    if (this.settings.caseSensitive) {
      return this.snippets.get(key);
    } else {
      const lowerKey = key.toLowerCase();
      for (const [k, v] of this.snippets) {
        if (k.toLowerCase() === lowerKey) {
          return v;
        }
      }
    }
    return void 0;
  }
  /**
   * Get all snippet keys (for autocomplete, debugging, etc.)
   */
  getAllKeys() {
    return Array.from(this.snippets.keys());
  }
  /**
   * Update settings reference
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Process a template with context
   */
  processSnippet(snippet, context) {
    const processed = this.parser.processTemplate(snippet.template, context);
    return this.parser.extractCursorMarker(processed);
  }
};

// src/eventHandler.ts
var import_obsidian = require("obsidian");

// src/types.ts
var DEFAULT_SETTINGS = {
  enableSpaceTrigger: true,
  enableTabTrigger: true,
  enableEnterTrigger: true,
  jsonFilePath: "snippets.json",
  parseInlineSnippets: true,
  caseSensitive: false,
  minKeyLength: 2,
  expandDelay: 0
};
var TRIGGER_KEYS = {
  Space: " ",
  Tab: "Tab",
  Enter: "Enter"
};

// src/eventHandler.ts
var SnippetEventHandler = class {
  constructor(snippetManager, settings) {
    this.isProcessing = false;
    this.snippetManager = snippetManager;
    this.settings = settings;
  }
  /**
   * Main keydown handler
   * This will be called BEFORE Obsidian's handlers due to capture phase
   */
  handleKeyDown(event) {
    if (this.isProcessing) return false;
    const isTrigger = this.isTriggerKey(event);
    if (!isTrigger) return false;
    const view = this.getActiveMarkdownView();
    if (!view) return false;
    const editor = view.editor;
    if (!editor) return false;
    const expanded = this.attemptExpansion(editor, event.key);
    if (expanded) {
      event.preventDefault();
      event.stopPropagation();
      event.stopImmediatePropagation();
      return true;
    }
    return false;
  }
  /**
   * Check if the pressed key is a configured trigger
   */
  isTriggerKey(event) {
    if (event.ctrlKey || event.altKey || event.metaKey) {
      return false;
    }
    const key = event.key;
    if (key === TRIGGER_KEYS.Space && this.settings.enableSpaceTrigger) {
      return true;
    }
    if (key === TRIGGER_KEYS.Tab && this.settings.enableTabTrigger) {
      return true;
    }
    if (key === TRIGGER_KEYS.Enter && this.settings.enableEnterTrigger) {
      return true;
    }
    return false;
  }
  /**
   * Attempt to expand snippet at current cursor position
   */
  attemptExpansion(editor, triggerKey) {
    this.isProcessing = true;
    try {
      const cursor = editor.getCursor();
      const lineText = editor.getLine(cursor.line);
      const textBeforeCursor = lineText.substring(0, cursor.ch);
      const wordMatch = textBeforeCursor.match(/(\S+)$/);
      if (!wordMatch) {
        return false;
      }
      const word = wordMatch[1];
      if (word.length < this.settings.minKeyLength) {
        return false;
      }
      const snippet = this.snippetManager.findSnippet(word);
      if (!snippet) {
        return false;
      }
      this.expandSnippet(editor, cursor, word, snippet, triggerKey);
      return true;
    } finally {
      this.isProcessing = false;
    }
  }
  /**
   * Perform the actual text expansion
   */
  expandSnippet(editor, cursor, matchedWord, snippet, triggerKey) {
    const view = this.getActiveMarkdownView();
    const context = {
      fileName: view?.file?.basename,
      filePath: view?.file?.path
    };
    const [expandedText, cursorOffset] = this.snippetManager.processSnippet(
      snippet,
      context
    );
    const wordStart = cursor.ch - matchedWord.length;
    const from = { line: cursor.line, ch: wordStart };
    const to = { line: cursor.line, ch: cursor.ch };
    let insertText = expandedText;
    if (triggerKey === TRIGGER_KEYS.Space) {
      insertText = expandedText + " ";
    } else if (triggerKey === TRIGGER_KEYS.Enter) {
      insertText = expandedText + "\n";
    }
    editor.replaceRange(insertText, from, to);
    if (cursorOffset !== null) {
      this.setCursorFromOffset(editor, from, insertText, cursorOffset);
    } else {
      const newCursor = this.calculateEndPosition(editor, from, insertText);
      editor.setCursor(newCursor);
    }
  }
  /**
   * Set cursor based on offset within expanded text
   */
  setCursorFromOffset(editor, startPos, text, offset) {
    const textBeforeMarker = text.substring(0, offset);
    const lines = textBeforeMarker.split("\n");
    if (lines.length === 1) {
      editor.setCursor({
        line: startPos.line,
        ch: startPos.ch + offset
      });
    } else {
      const newLine = startPos.line + lines.length - 1;
      const newCh = lines[lines.length - 1].length;
      editor.setCursor({ line: newLine, ch: newCh });
    }
  }
  /**
   * Calculate end position after inserting multi-line text
   */
  calculateEndPosition(editor, startPos, text) {
    const lines = text.split("\n");
    if (lines.length === 1) {
      return {
        line: startPos.line,
        ch: startPos.ch + text.length
      };
    } else {
      return {
        line: startPos.line + lines.length - 1,
        ch: lines[lines.length - 1].length
      };
    }
  }
  /**
   * Get active markdown view
   */
  getActiveMarkdownView() {
    const view = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
    return view;
  }
  get app() {
    return this.snippetManager["app"];
  }
  /**
   * Update settings reference
   */
  updateSettings(settings) {
    this.settings = settings;
  }
};

// src/main.ts
var SnippetExpanderPlugin = class extends import_obsidian2.Plugin {
  async onload() {
    console.log("Loading Snippet Expander Plugin");
    await this.loadSettings();
    this.snippetManager = new SnippetManager(this.app, this.settings);
    this.eventHandler = new SnippetEventHandler(
      this.snippetManager,
      this.settings
    );
    await this.reloadSnippets();
    this.keydownHandler = this.createKeydownHandler();
    this.registerDomEvent(
      document,
      "keydown",
      this.keydownHandler,
      { capture: true }
      // CRITICAL: Use capture phase for priority
    );
    this.addCommand({
      id: "reload-snippets",
      name: "Reload snippets",
      callback: async () => {
        await this.reloadSnippets();
      }
    });
    this.addCommand({
      id: "expand-snippet-manual",
      name: "Expand snippet at cursor",
      editorCallback: (editor, view) => {
        if (view instanceof import_obsidian2.MarkdownView) {
          this.manualExpand(editor, view);
        } else {
          console.log("Manual expansion is only available in Markdown views.");
        }
      }
    });
    this.addCommand({
      id: "list-snippets",
      name: "List all loaded snippets",
      callback: () => {
        const keys = this.snippetManager.getAllKeys();
        console.log(`Loaded snippets (${keys.length}):`, keys);
      }
    });
    this.addSettingTab(new SnippetSettingsTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-open", async (file) => {
        if (this.settings.parseInlineSnippets && file) {
          await this.reloadSnippets();
        }
      })
    );
    let debounceTimer = null;
    this.registerEvent(
      this.app.workspace.on("editor-change", () => {
        if (!this.settings.parseInlineSnippets) return;
        if (debounceTimer) clearTimeout(debounceTimer);
        debounceTimer = setTimeout(async () => {
          await this.reloadSnippets();
        }, 500);
      })
    );
  }
  /**
   * Create the keydown handler with proper binding
   */
  createKeydownHandler() {
    return (event) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView) return;
      const editor = activeView.editor;
      if (!editor) return;
      this.eventHandler.handleKeyDown(event);
    };
  }
  /**
   * Reload snippets from all sources
   */
  async reloadSnippets() {
    const activeFile = this.app.workspace.getActiveFile();
    await this.snippetManager.reloadSnippets(activeFile);
  }
  /**
   * Manual expansion (command-triggered)
   */
  manualExpand(editor, view) {
    const cursor = editor.getCursor();
    const lineText = editor.getLine(cursor.line);
    const textBeforeCursor = lineText.substring(0, cursor.ch);
    const wordMatch = textBeforeCursor.match(/(\S+)$/);
    if (!wordMatch) return;
    const word = wordMatch[1];
    const snippet = this.snippetManager.findSnippet(word);
    if (!snippet) {
      console.log(`No snippet found for: ${word}`);
      return;
    }
    const context = {
      fileName: view.file?.basename,
      filePath: view.file?.path
    };
    const [expandedText, cursorOffset] = this.snippetManager.processSnippet(
      snippet,
      context
    );
    const wordStart = cursor.ch - word.length;
    const from = { line: cursor.line, ch: wordStart };
    const to = cursor;
    editor.replaceRange(expandedText, from, to);
    if (cursorOffset !== null) {
      const textBeforeMarker = expandedText.substring(0, cursorOffset);
      const lines = textBeforeMarker.split("\n");
      const newLine = cursor.line + lines.length - 1;
      const newCh = lines.length === 1 ? wordStart + cursorOffset : lines[lines.length - 1].length;
      editor.setCursor({ line: newLine, ch: newCh });
    }
  }
  async onunload() {
    console.log("Unloading Snippet Expander Plugin");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.snippetManager.updateSettings(this.settings);
    this.eventHandler.updateSettings(this.settings);
    await this.reloadSnippets();
  }
};
var SnippetSettingsTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Snippet Expander Settings" });
    containerEl.createEl("h3", { text: "Trigger Keys" });
    new import_obsidian2.Setting(containerEl).setName("Expand on Space").setDesc("Trigger snippet expansion when Space is pressed").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSpaceTrigger).onChange(async (value) => {
      this.plugin.settings.enableSpaceTrigger = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Expand on Tab").setDesc("Trigger snippet expansion when Tab is pressed").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTabTrigger).onChange(async (value) => {
      this.plugin.settings.enableTabTrigger = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Expand on Enter").setDesc("Trigger snippet expansion when Enter is pressed").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableEnterTrigger).onChange(async (value) => {
      this.plugin.settings.enableEnterTrigger = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Snippet Sources" });
    new import_obsidian2.Setting(containerEl).setName("JSON file path").setDesc("Filename for JSON snippets (in plugin folder)").addText((text) => text.setPlaceholder("snippets.json").setValue(this.plugin.settings.jsonFilePath).onChange(async (value) => {
      this.plugin.settings.jsonFilePath = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Parse inline snippets").setDesc("Load snippets from current markdown file").addToggle((toggle) => toggle.setValue(this.plugin.settings.parseInlineSnippets).onChange(async (value) => {
      this.plugin.settings.parseInlineSnippets = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Behavior" });
    new import_obsidian2.Setting(containerEl).setName("Case sensitive").setDesc("Match snippet keys with case sensitivity").addToggle((toggle) => toggle.setValue(this.plugin.settings.caseSensitive).onChange(async (value) => {
      this.plugin.settings.caseSensitive = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian2.Setting(containerEl).setName("Minimum key length").setDesc("Minimum characters before attempting expansion").addSlider((slider) => slider.setLimits(1, 5, 1).setValue(this.plugin.settings.minKeyLength).setDynamicTooltip().onChange(async (value) => {
      this.plugin.settings.minKeyLength = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Actions" });
    new import_obsidian2.Setting(containerEl).setName("Reload snippets now").setDesc("Manually reload all snippets from sources").addButton((button) => button.setButtonText("Reload").onClick(async () => {
      await this.plugin.reloadSnippets();
    }));
    new import_obsidian2.Setting(containerEl).setName("Show loaded snippets").setDesc("Display list of currently loaded snippet keys").addButton((button) => button.setButtonText("Show").onClick(() => {
      const keys = this.plugin.snippetManager.getAllKeys();
      console.log(`Loaded snippets (${keys.length}):`, keys.sort());
    }));
  }
};
